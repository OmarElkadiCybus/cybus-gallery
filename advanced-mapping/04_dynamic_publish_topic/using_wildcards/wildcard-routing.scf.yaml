description: >
  Building automation system showing wildcard-based dynamic publish topics.
  Route sensor data to room-specific and sensor-specific output topics.
  Includes UNS (Unified Namespace) implementation examples.

metadata:
  name: Building Automation & UNS - Wildcard Dynamic Publishing

resources:
  # Route temperature alerts to room-specific topics
  temperatureAlertMapping:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: sensors/+room/temperature/readings
        publish:
          topic: 'alerts/{room}/temperature/status'
        rules:
        - transform:
            expression: |
              {
                "timestamp": $now(),
                "room": $context.vars.room,
                "temperature": $.value,
                "status": $.value > 25 ? "high" : $.value < 18 ? "low" : "normal",
                "source_topic": $context.topic,
                "alert_topic": "alerts/" & $context.vars.room & "/temperature/status"
              }
    # Example Flow: Topic structure determines output routing
    #
    # Input: sensors/kitchen/temperature/readings → {"value": 27.5, "unit": "celsius"}
    # Wildcards: $context.vars.room = "kitchen"
    # Output Topic: alerts/kitchen/temperature/status
    # Output Payload: {
    #   "timestamp": 1730115600000,
    #   "room": "kitchen", 
    #   "temperature": 27.5,
    #   "status": "high",
    #   "source_topic": "sensors/kitchen/temperature/readings",
    #   "alert_topic": "alerts/kitchen/temperature/status"
    # }

  # Route device diagnostics to device-specific maintenance topics
  deviceDiagnosticsMapping:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: devices/+location/+deviceId/diagnostics
        publish:
          topic: 'maintenance/{location}/devices/{deviceId}/reports'
        rules:
        - transform:
            expression: |
              {
                "timestamp": $now(),
                "device_info": {
                  "location": $context.vars.location,
                  "device_id": $context.vars.deviceId,
                  "full_path": $context.vars.location & "/" & $context.vars.deviceId
                },
                "diagnostics": $,
                "maintenance_required": $.battery_level < 20 or $.error_count > 0,
                "routing_info": {
                  "source": $context.topic,
                  "destination": "maintenance/" & $context.vars.location & "/devices/" & $context.vars.deviceId & "/reports"
                }
              }
    # Example Flow: Multi-level wildcards for hierarchical routing
    #
    # Input: devices/floor-2/sensor-001/diagnostics → {"battery_level": 15, "error_count": 2, "signal_strength": -65}
    # Wildcards: $context.vars.location = "floor-2", $context.vars.deviceId = "sensor-001" 
    # Output Topic: maintenance/floor-2/devices/sensor-001/reports
    # Output Payload: {
    #   "timestamp": 1730115600000,
    #   "device_info": {
    #     "location": "floor-2",
    #     "device_id": "sensor-001", 
    #     "full_path": "floor-2/sensor-001"
    #   },
    #   "diagnostics": {"battery_level": 15, "error_count": 2, "signal_strength": -65},
    #   "maintenance_required": true,
    #   "routing_info": {
    #     "source": "devices/floor-2/sensor-001/diagnostics",
    #     "destination": "maintenance/floor-2/devices/sensor-001/reports"
    #   }
    # }

  # Multi-tenant system routing by tenant and service
  multiTenantServiceMapping:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: saas/+tenant/+service/events
        publish:
          topic: 'analytics/{tenant}/services/{service}/processed'
        rules:
        - transform:
            expression: |
              {
                "timestamp": $now(),
                "tenant_info": {
                  "tenant_id": $context.vars.tenant,
                  "service_name": $context.vars.service,
                  "namespace": $context.vars.tenant & "." & $context.vars.service
                },
                "event_data": $,
                "analytics_routing": {
                  "tenant_specific": true,
                  "service_isolation": true,
                  "output_topic": "analytics/" & $context.vars.tenant & "/services/" & $context.vars.service & "/processed"
                }
              }
    # Example Flow: SaaS tenant and service isolation through routing
    #
    # Input: saas/acme-corp/billing/events → {"event_type": "invoice_generated", "amount": 1250.00, "currency": "USD"}
    # Wildcards: $context.vars.tenant = "acme-corp", $context.vars.service = "billing"
    # Output Topic: analytics/acme-corp/services/billing/processed  
    # Output Payload: {
    #   "timestamp": 1730115600000,
    #   "tenant_info": {
    #     "tenant_id": "acme-corp",
    #     "service_name": "billing",
    #     "namespace": "acme-corp.billing"
    #   },
    #   "event_data": {"event_type": "invoice_generated", "amount": 1250.00, "currency": "USD"},
    #   "analytics_routing": {
    #     "tenant_specific": true,
    #     "service_isolation": true, 
    #     "output_topic": "analytics/acme-corp/services/billing/processed"
    #   }
    # }

  # UNS (Unified Namespace) Implementation - Transform enterprise data into standardized hierarchy
  unsEnterpriseMapping:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: legacy/+site/+area/+line/+asset/data
        publish:
          topic: 'UNS/Enterprise/{site}/Area/{area}/Line/{line}/Asset/{asset}'
        rules:
        - transform:
            expression: |
              {
                "timestamp": $now(),
                "uns_metadata": {
                  "enterprise": "Manufacturing Corp",
                  "site": $context.vars.site,
                  "area": $context.vars.area,
                  "line": $context.vars.line,
                  "asset": $context.vars.asset,
                  "hierarchy_path": "Enterprise/" & $context.vars.site & "/Area/" & $context.vars.area & "/Line/" & $context.vars.line & "/Asset/" & $context.vars.asset,
                  "legacy_source": $context.topic
                },
                "process_data": $,
                "uns_compliant": true,
                "data_model": "ISA-95 Level " & ($.asset_type = "sensor" ? "0" : $.asset_type = "machine" ? "1" : "2")
              }
    # Example Flow: Legacy system data transformed to UNS standard hierarchy
    #
    # Input: legacy/plant-01/production/line-a/robot-arm-02/data → {
    #   "asset_type": "machine",
    #   "status": "running",
    #   "oee": 0.85,
    #   "cycle_time": 45.2,
    #   "quality_rate": 0.98
    # }
    #
    # Wildcards: site="plant-01", area="production", line="line-a", asset="robot-arm-02"
    # Output Topic: UNS/Enterprise/plant-01/Area/production/Line/line-a/Asset/robot-arm-02
    # Output Payload: {
    #   "timestamp": 1730115600000,
    #   "uns_metadata": {
    #     "enterprise": "Manufacturing Corp",
    #     "site": "plant-01",
    #     "area": "production", 
    #     "line": "line-a",
    #     "asset": "robot-arm-02",
    #     "hierarchy_path": "Enterprise/plant-01/Area/production/Line/line-a/Asset/robot-arm-02",
    #     "legacy_source": "legacy/plant-01/production/line-a/robot-arm-02/data"
    #   },
    #   "process_data": {original payload},
    #   "uns_compliant": true,
    #   "data_model": "ISA-95 Level 1"
    # }
    #
    # UNS Benefits:
    # ✅ Standardized enterprise-wide data hierarchy
    # ✅ ISA-95 compliant data modeling
    # ✅ Legacy system integration with modern namespace
    # ✅ Consistent data discovery and navigation across enterprise