description: >
  Edge computing examples with parse rules applied directly at endpoints.
  Seven progressive examples demonstrate parsing different data formats
  (strings, binary integers, floats, base64, JSON) from industrial protocols.
  Includes error handling patterns for production deployment.

metadata:
  name: Parse Rule - Broker and Edge Parsing Examples

resources:
  # ============================================================================
  # INDEPENDENT EDGE PARSING EXAMPLES: Parse Rules Applied Directly at Endpoints
  # Each endpoint demonstrates parsing input data at the edge level before any
  # mapping or further processing. This approach enables:
  # - Edge computing: Data transformation at source
  # - Reduced network traffic: Only processed data is transmitted
  # - Independent operation: Each endpoint is self-contained
  # 
  # NOTE: Connection definitions (mqtt_connection, modbus_connection, s7_connection, 
  # opcua_connection, http_connection) are referenced with !ref but not defined here.
  # These would need to be added in a complete service configuration.
  # 
  # VERSION COMPATIBILITY:
  # - Basic formats (boolean, utf8, int16BE, uint16BE, etc.): All versions
  # ============================================================================

  # Level 1: STRING Parsing - CSV Sensor Data (Edge Processing)
  csv_sensor_endpoint:
    type: Cybus::Endpoint
    properties:
      protocol: Mqtt
      connection: !ref mqtt_connection
      subscribe:
        topic: 'sensors/csv/raw'
      rules:
      - parse:
          format: utf8      # Convert raw MQTT bytes to UTF-8 string
      - transform:
          expression: |
            {
              "sensor": $split($, ',')[0],
              "value": $number($split($, ',')[1]),
              "timestamp": $now()
            }
    # Edge Processing Flow:
    # Input:  [0x54,0x45,0x4D,0x50,0x30,0x31,0x2C,0x32,0x33,0x2E,0x35] (raw bytes)
    # Parse:  "TEMP01,23.5" (UTF-8 string)
    # Output: {"sensor": "TEMP01", "value": 23.5, "timestamp": "..."}
    # Use Case: CSV sensor data over MQTT

  # Level 2: BINARY Integer Parsing - Modbus Temperature (Edge Processing)
  modbus_temperature_endpoint:
    type: Cybus::Endpoint
    properties:
      protocol: Modbus
      connection: !ref modbus_connection
      subscribe:
        fc: 3
        address: 40001
        length: 1
      rules:
      - parse:
          format: int16BE     # Parse raw register as 16-bit big-endian signed integer
      - transform:
          expression: $ / 10  # Scale from register value to temperature
    # Edge Processing Flow:
    # Input:  [0x03,0x20] (raw Modbus register bytes)
    # Parse:  800 (int16BE format)
    # Output: 80.0 (scaled temperature value)
    # Use Case: Scaled temperature registers

  # Level 3: UNSIGNED Integer Parsing - S7 Counter (Edge Processing)
  s7_counter_endpoint:
    type: Cybus::Endpoint
    properties:
      protocol: S7
      connection: !ref s7_connection
      subscribe:
        address: 'DB1.DBW0'
        length: 2
      rules:
      - parse:
          format: uint16BE    # Parse raw bytes as unsigned 16-bit big-endian
      - transform:
          expression: |
            {
              "counter": $,
              "plc_type": "s7",
              "timestamp": $now()
            }
    # Edge Processing Flow:
    # Input:  [0x01,0x00] (raw S7 data block bytes)
    # Parse:  256 (uint16BE - big-endian interpretation)
    # Output: {"counter": 256, "plc_type": "s7", "timestamp": "..."}
    # Use Case: Production counters from Siemens S7 PLCs

  # Level 4: MULTI-SENSOR Parsing - S7 Temperature Array (Edge Processing)
  s7_multisensor_endpoint:
    type: Cybus::Endpoint
    properties:
      protocol: S7
      connection: !ref s7_connection
      subscribe:
        address: 'DB2.DBW0'
        length: 20             # 20 bytes for 10 sensors (2 bytes each)
      rules:
      - parse:
          format: int16BE     # Parse first sensor value from data block
      - transform:
          expression: |
            {
              "temperature": $ / 100,
              "sensor_block": "DB2",
              "status": "active"
            }
    # Edge Processing Flow:
    # Input:  [0x09,0xC4, 0x0A,0x28, 0x09,0xF6, ...] (20 bytes for 10 sensors)
    # Parse:  2500 (first int16BE value from byte array)
    # Output: {"temperature": 25.0, "sensor_block": "DB2", "status": "active"}
    # Use Case: Multi-channel temperature monitoring from PLC data blocks

  # Level 5: BASE64 Text Parsing - LoRaWAN Messages (Edge Processing)
  lorawan_endpoint:
    type: Cybus::Endpoint
    properties:
      protocol: Mqtt
      connection: !ref mqtt_connection
      subscribe:
        topic: 'lorawan/+/uplink'
      rules:
      - parse:
          format: fromBase64  # Decode base64 string to plain text
      - transform:
          expression: |
            {
              "device": $split($context.topic, '/')[1],
              "payload": $,
              "length": $length($),
              "decoded": "base64_to_text"
            }
    # Edge Processing Flow:
    # Input:  "SGVsbG8gV29ybGQ=" (base64 encoded string)
    # Parse:  "Hello World" (plain text string)
    # Output: {"device": "DEV001", "payload": "Hello World", "length": 11, "decoded": "base64_to_text"}
    # Use Case: Base64 encoded text messages from IoT devices

  # Level 6: FLOAT Parsing - OPC-UA Temperature (Edge Processing)
  opcua_temperature_endpoint:
    type: Cybus::Endpoint
    properties:
      protocol: Opcua
      connection: !ref opcua_connection
      subscribe:
        nodeId: 'ns=2;i=1001'
      rules:
      - parse:
          format: floatBE     # Parse raw bytes as 32-bit IEEE 754 big-endian float
      - transform:
          expression: |
            {
              "temperature": $,
              "unit": "celsius",
              "source": "opcua"
            }
    # Edge Processing Flow:
    # Input:  [0x42,0x20,0x00,0x00] (raw OPC-UA float bytes)
    # Parse:  40.0 (IEEE 754 float)
    # Output: {"temperature": 40.0, "unit": "celsius", "source": "opcua"}
    # Use Case: High-precision temperature readings from OPC-UA servers
        
  # Level 7: JSON Parsing - HTTP API Data (Edge Processing)
  http_api_endpoint:
    type: Cybus::Endpoint
    properties:
      protocol: Http
      connection: !ref http_connection
      subscribe:
        path: '/api/sensors'
        method: post
      rules:
      - parse:
          format: json        # Parse JSON string to object
      - transform:
          expression: |
            {
              "sensors": $.data,
              "api_status": $.status,
              "timestamp": $now()
            }
    # Edge Processing Flow:
    # Input:  '{"data": [{"id": 1, "value": 23.5}], "status": "ok"}' (JSON string)
    # Parse:  {"data": [...], "status": "ok"} (JSON object)
    # Output: {"sensors": [...], "api_status": "ok", "timestamp": "..."}
    # Use Case: REST API integration with JSON sensor data

  # BONUS: Error Handling Example - Resilient Parsing (Edge Processing)
  resilient_parsing_endpoint:
    type: Cybus::Endpoint
    properties:
      protocol: Mqtt
      connection: !ref mqtt_connection
      subscribe:
        topic: 'sensors/mixed/+/data'
      rules:
      - parse:
          format: utf8        # Attempt to parse as UTF-8 string
      - transform:
          expression: |
            $exists($) and $length($) > 0 ? 
            {
              "device": $split($context.topic, '/')[2],
              "data": $,
              "parsed": true,
              "timestamp": $now()
            } : 
            {
              "device": $split($context.topic, '/')[2],
              "error": "Parse failed or empty payload",
              "parsed": false,
              "timestamp": $now()
            }
    # Error Handling Flow:
    # Success: Valid UTF-8 → {"device": "DEV001", "data": "sensor_data", "parsed": true}
    # Failure: Invalid data → {"device": "DEV001", "error": "Parse failed...", "parsed": false}
    # Use Case: Mixed data sources requiring resilient processing