description: >
  Simple stash rule examples showing different stash patterns:
  basic comparisons, multiple stashes, and stateful processing.

metadata:
  name: Stash Rule - Order Examples

resources:
  # Order 1: STASH FIRST - Store raw input, then process
  stashFirst:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: sensors/raw
        publish:
          topic: processed/stash_first
        rules:
        - stash:
            label: rawData        # Store original input first
        - transform:
            expression: |
              {
                "current": $.temperature,
                "previous": $last("rawData") ? $last("rawData").temperature : null
              }
    # What gets stashed: Original raw input message
    #
    # Message 1:
    # Input: {"temperature": 25, "sensor": "A1"}
    # Stashed: {"temperature": 25, "sensor": "A1"}
    # Output: {"current": 25, "previous": null}
    #
    # Message 2:
    # Input: {"temperature": 28, "sensor": "A1"}  
    # Previous: {"temperature": 25, "sensor": "A1"} (raw input)
    # Output: {"current": 28, "previous": 25}

  # Order 2: STASH LAST - Process first, then store result
  stashLast:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: sensors/raw
        publish:
          topic: processed/stash_last
        rules:
        - transform:
            expression: |
              {
                "current": $.temperature,
                "previous": $last("processed") ? $last("processed").current : null,
                "sensor": $.sensor
              }
        - stash:
            label: processed      # Store processed result
    # What gets stashed: Processed/transformed message
    #
    # Message 1:
    # Input: {"temperature": 25, "sensor": "A1"}
    # Output: {"current": 25, "previous": null, "sensor": "A1"}
    # Stashed: {"current": 25, "previous": null, "sensor": "A1"}
    #
    # Message 2:
    # Input: {"temperature": 28, "sensor": "A1"}
    # Previous: {"current": 25, "previous": null, "sensor": "A1"} (processed)
    # Output: {"current": 28, "previous": 25, "sensor": "A1"}

  # Order 3: MULTIPLE STASHES - Store different data at different stages
  multipleStashes:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: sensors/complex
        publish:
          topic: processed/multi_stash
        rules:
        # Step 1: Store original input before any processing
        - stash:
            label: original      # Store raw input for next message
        
        # Step 2: Process the data
        - transform:
            expression: |
              {
                "doubled_value": $.reading * 2,
                "sensor_name": $.sensor_id,
                "processing_time": $now()
              }
        
        # Step 3: Create final output with access to BOTH current and previous data
        - transform:
            expression: |
              {
                "current": {
                  "raw_reading": $.reading,
                  "processed_value": $.doubled_value,
                  "sensor": $.sensor_name
                },
                "previous": {
                  "raw_reading": $last("original") ? $last("original").reading : null,
                  "processed_value": $last("processed") ? $last("processed").doubled_value : null,
                  "sensor": $last("processed") ? $last("processed").sensor_name : null
                },
                "comparison": {
                  "raw_change": $last("original") ? $.reading - $last("original").reading : 0,
                  "processed_change": $last("processed") ? $.doubled_value - $last("processed").doubled_value : 0
                }
              }
        
        # Step 4: Store processed result for next message
        - stash:
            label: processed     # Store processed data for next message
    # CORRECT Multiple Stash Logic: Two stashes store different data types
    #
    # Message 1:
    # Input: {"reading": 10, "sensor_id": "S1"}
    # Step 1 - Stash original: Stores {"reading": 10, "sensor_id": "S1"} for NEXT message
    # Step 2 - Process: {"doubled_value": 20, "sensor_name": "S1", "processing_time": "..."}
    # Step 3 - Final transform: $last("original"): null, $last("processed"): null (first message)
    # Output: {
    #   "current": {"raw_reading": 10, "processed_value": 20, "sensor": "S1"},
    #   "previous": {"raw_reading": null, "processed_value": null, "sensor": null},
    #   "comparison": {"raw_change": 0, "processed_change": 0}
    # }
    # Step 4 - Stash processed: Stores processed data for NEXT message
    #
    # Message 2:
    # Input: {"reading": 15, "sensor_id": "S1"}
    # Step 1 - Stash original: Stores {"reading": 15, "sensor_id": "S1"} for NEXT message
    # Step 2 - Process: {"doubled_value": 30, "sensor_name": "S1", "processing_time": "..."}
    # Step 3 - Final transform: 
    #   $last("original"): {"reading": 10, "sensor_id": "S1"} (from message 1)
    #   $last("processed"): {"doubled_value": 20, "sensor_name": "S1", ...} (from message 1)
    # Output: {
    #   "current": {"raw_reading": 15, "processed_value": 30, "sensor": "S1"},
    #   "previous": {"raw_reading": 10, "processed_value": 20, "sensor": "S1"},
    #   "comparison": {"raw_change": 5, "processed_change": 10}
    # }

  # Order 5: SIMPLE COMPARISON - Just compare values
  simpleComparison:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: values/simple
        publish:
          topic: compared/simple
        rules:
        - transform:
            expression: |
              {
                "current": $.value,
                "previous": $last("simple") ? $last("simple").value : null
              }
        - stash:
            label: simple
    # Simplest possible stash example
    #
    # Message 1:
    # Input: {"value": 100}
    # Output: {"current": 100, "previous": null}
    # Stashed: {"value": 100}
    #
    # Message 2:
    # Input: {"value": 150}
    # Previous: {"value": 100}
    # Output: {"current": 150, "previous": 100}

  # Order 8: ESSENTIAL STASH - Per-Station Counter (Real-World Pattern)
  perStationCounter:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          - topic: stations/+StationName/events
            label: 'station_{StationName}'
        publish:
          topic: analytics/station_events
        rules:
        # Step 1: Collect station events
        - collect: {}
        
        # Step 2: Build counters per station (DEPENDS on stashed counters)
        - transform:
            expression: |
              (
                $stationName := $context.vars.StationName;
                $previousCounters := $last("counters") ? $last("counters").station_counters : {};
                $currentCount := $lookup($previousCounters, $stationName) ? $lookup($previousCounters, $stationName) : 0;
                $newCount := $currentCount + 1;
                $updatedCounters := $merge([$previousCounters, {($stationName): $newCount}]);
                
                {
                  "station_counters": $updatedCounters,
                  "current_event": {
                    "station": $stationName,
                    "count": $newCount,
                    "event_data": $lookup($, "station_" & $stationName)
                  }
                }
              )
        
        # Step 3: Stash counters (ESSENTIAL - needed for per-station counting)
        - stash:
            label: counters
        
        # Step 4: Deliver clean event notification
        - transform:
            expression: |
              {
                "station": $.current_event.station,
                "event_number": $.current_event.count,
                "event_type": $.current_event.event_data.type,
                "timestamp": $.current_event.event_data.timestamp
              }
    # ESSENTIAL Stash: Maintains separate counters for each station
    #
    # Event 1 - Station A:
    # Input: stations/A/events: {"type": "start", "timestamp": "..."}
    # Context: StationName = "A"
    # Previous counters: {} (empty)
    # New counters: {"A": 1}
    # Stashed: {"station_counters": {"A": 1}, ...}
    # Output: {"station": "A", "event_number": 1, "event_type": "start", "timestamp": "..."}
    #
    # Event 2 - Station B:
    # Input: stations/B/events: {"type": "complete", "timestamp": "..."}
    # Context: StationName = "B" 
    # Previous counters: {"A": 1}
    # New counters: {"A": 1, "B": 1}
    # Stashed: {"station_counters": {"A": 1, "B": 1}, ...}
    # Output: {"station": "B", "event_number": 1, "event_type": "complete", "timestamp": "..."}
    #
    # Event 3 - Station A again:
    # Input: stations/A/events: {"type": "error", "timestamp": "..."}
    # Context: StationName = "A"
    # Previous counters: {"A": 1, "B": 1}
    # New counters: {"A": 2, "B": 1}
    # Output: {"station": "A", "event_number": 2, "event_type": "error", "timestamp": "..."}
