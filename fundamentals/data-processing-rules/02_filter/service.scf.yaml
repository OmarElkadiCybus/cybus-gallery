description: >
  A filter rule example that only forwards error messages
  based on severity level for alert processing.

metadata:
  name: Filter Rule - Error Log Filtering

resources:
  # ============================================================================
  # PROGRESSIVE FILTER EXAMPLES: Building from Basic to Advanced Usage
  # ============================================================================

  # Level 1: BASIC Filter - Simple Field Value Matching
  # Pass through messages where a specific field equals a value
  basicFieldFilter:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: system/logs
        publish:
          topic: system/logs/errors
        rules:
        - filter:
            expression: level = "ERROR"    # Simple field comparison
    # Input Messages:
    # system/logs: {"level": "INFO", "message": "System started", "timestamp": "10:00:01"}    ← FILTERED
    # system/logs: {"level": "ERROR", "message": "Database connection failed", "timestamp": "10:00:02"} ← PASSES
    # system/logs: {"level": "WARN", "message": "High memory usage", "timestamp": "10:00:03"}  ← FILTERED
    # system/logs: {"level": "ERROR", "message": "Service timeout", "timestamp": "10:00:04"}  ← PASSES
    #
    # Output Messages (only ERROR level):
    # system/logs/errors: {"level": "ERROR", "message": "Database connection failed", "timestamp": "10:00:02"}
    # system/logs/errors: {"level": "ERROR", "message": "Service timeout", "timestamp": "10:00:04"}

  # Level 2: NUMERIC Filter - Range and Comparison Filtering
  # Filter based on numeric value thresholds
  numericRangeFilter:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: sensors/temperature/readings
        publish:
          topic: sensors/temperature/high-temp-alerts
        rules:
        - filter:
            expression: temperature > 85    # Numeric comparison
    # Input Messages:
    # sensors/temperature/readings: {"temperature": 75.5, "sensor_id": "T001", "location": "engine"}     ← FILTERED (75.5 ≤ 85)
    # sensors/temperature/readings: {"temperature": 87.2, "sensor_id": "T002", "location": "exhaust"}    ← PASSES (87.2 > 85)
    # sensors/temperature/readings: {"temperature": 82.1, "sensor_id": "T003", "location": "coolant"}    ← FILTERED (82.1 ≤ 85)
    # sensors/temperature/readings: {"temperature": 89.8, "sensor_id": "T001", "location": "engine"}     ← PASSES (89.8 > 85)
    #
    # Output Messages (only high temperatures):
    # sensors/temperature/high-temp-alerts: {"temperature": 87.2, "sensor_id": "T002", "location": "exhaust"}
    # sensors/temperature/high-temp-alerts: {"temperature": 89.8, "sensor_id": "T001", "location": "engine"}

  # Level 3: COMPLEX Conditions - Multiple Field Logic
  # Combine multiple conditions with AND/OR logic
  complexConditionFilter:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: production/quality/measurements
        publish:
          topic: production/quality/defects
        rules:
        - filter:
            expression: |
              (diameter < 24.95 or diameter > 25.05) and status = "completed"
    # Input Messages:
    # production/quality/measurements: {"diameter": 25.02, "status": "completed", "part_id": "P001"}   ← FILTERED (diameter in spec)
    # production/quality/measurements: {"diameter": 24.92, "status": "completed", "part_id": "P002"}   ← PASSES (diameter < 24.95)
    # production/quality/measurements: {"diameter": 25.08, "status": "in_progress", "part_id": "P003"} ← FILTERED (status ≠ completed)
    # production/quality/measurements: {"diameter": 25.12, "status": "completed", "part_id": "P004"}   ← PASSES (diameter > 25.05)
    #
    # Output Messages (only completed parts with defects):
    # production/quality/defects: {"diameter": 24.92, "status": "completed", "part_id": "P002"}
    # production/quality/defects: {"diameter": 25.12, "status": "completed", "part_id": "P004"}

  # Level 4: ARRAY and OBJECT Filtering - Complex Data Structure Filtering
  # Filter based on array contents or nested object properties
  arrayObjectFilter:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: equipment/maintenance/reports
        publish:
          topic: equipment/maintenance/critical-issues
        rules:
        - filter:
            expression: |
              $count(issues[severity = "critical"]) > 0 and equipment.operational = false
    # Input Messages:
    # equipment/maintenance/reports: {
    #   "equipment": {"id": "CNC-001", "operational": true},
    #   "issues": [{"type": "vibration", "severity": "minor"}]
    # } ← FILTERED (no critical issues)
    #
    # equipment/maintenance/reports: {
    #   "equipment": {"id": "PRESS-002", "operational": false}, 
    #   "issues": [{"type": "hydraulic_leak", "severity": "critical"}, {"type": "wear", "severity": "minor"}]
    # } ← PASSES (has critical issue AND not operational)
    #
    # equipment/maintenance/reports: {
    #   "equipment": {"id": "ROBOT-003", "operational": true},
    #   "issues": [{"type": "calibration", "severity": "critical"}]
    # } ← FILTERED (operational = true)
    #
    # Output Messages (only non-operational equipment with critical issues):
    # equipment/maintenance/critical-issues: {
    #   "equipment": {"id": "PRESS-002", "operational": false},
    #   "issues": [{"type": "hydraulic_leak", "severity": "critical"}, {"type": "wear", "severity": "minor"}]
    # }

  # Level 5: WILDCARD Filter with Context Variables
  # Use wildcard subscriptions and context variables in filter expressions
  wildcardContextFilter:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: factory/+line/+machine/alarms
          label: '{line}_{machine}'
        publish:
          topic: factory/alarms/production-critical
        rules:
        - filter:
            expression: |
              alarm_type = "production_stop" and $contains($context.topic, "line-a")
    # Input Messages:
    # factory/line-a/cnc-001/alarms: {"alarm_type": "production_stop", "message": "Emergency stop activated"}     ← PASSES
    # factory/line-a/robot-arm/alarms: {"alarm_type": "maintenance", "message": "Scheduled maintenance due"}      ← FILTERED (not production_stop)
    # factory/line-b/cnc-002/alarms: {"alarm_type": "production_stop", "message": "Material jam detected"}       ← FILTERED (not line-a)
    # factory/line-a/conveyor/alarms: {"alarm_type": "production_stop", "message": "Conveyor belt stopped"}      ← PASSES
    #
    # Output Messages (only line-a production stops):
    # factory/alarms/production-critical: {"alarm_type": "production_stop", "message": "Emergency stop activated"}
    # factory/alarms/production-critical: {"alarm_type": "production_stop", "message": "Conveyor belt stopped"}

  # Level 6: FILTER + TRANSFORM Combination
  # Filter messages then transform the results
  filterTransformCombination:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: vehicles/+vehicle_id/telemetry
        publish:
          topic: vehicles/maintenance/alerts
        rules:
        - filter:
            expression: |
              engine_temp > 95 or oil_pressure < 30 or battery_voltage < 11.5
        - transform:
            expression: |
              {
                "vehicle_id": $context.label,
                "alert_type": "maintenance_required",
                "conditions": {
                  "engine_overheating": engine_temp > 95,
                  "low_oil_pressure": oil_pressure < 30, 
                  "low_battery": battery_voltage < 11.5
                },
                "severity": (engine_temp > 100 or oil_pressure < 25) ? "critical" : "warning",
                "timestamp": $now(),
                "recommended_action": engine_temp > 100 ? "immediate_shutdown" : "schedule_maintenance"
              }
    # Input Messages:
    # vehicles/truck-001/telemetry: {"engine_temp": 92, "oil_pressure": 35, "battery_voltage": 12.2}  ← FILTERED (all values normal)
    # vehicles/truck-002/telemetry: {"engine_temp": 98, "oil_pressure": 28, "battery_voltage": 12.0}  ← PASSES (oil_pressure < 30)
    # vehicles/van-003/telemetry: {"engine_temp": 102, "oil_pressure": 32, "battery_voltage": 11.2}   ← PASSES (engine_temp > 95, battery < 11.5)
    #
    # Output Messages (filtered + transformed):
    # vehicles/maintenance/alerts: {
    #   "vehicle_id": "truck-002",
    #   "alert_type": "maintenance_required", 
    #   "conditions": {"engine_overheating": false, "low_oil_pressure": true, "low_battery": false},
    #   "severity": "warning"
    # }
    # vehicles/maintenance/alerts: {
    #   "vehicle_id": "van-003",
    #   "alert_type": "maintenance_required",
    #   "conditions": {"engine_overheating": true, "low_oil_pressure": false, "low_battery": true}, 
    #   "severity": "critical",
    #   "recommended_action": "immediate_shutdown"
    # }

  # Level 7: ADVANCED JSONata Functions - Complex Data Processing
  # Use advanced JSONata functions for sophisticated filtering
  advancedJsonataFilter:
    type: Cybus::Mapping
    properties:
      mappings:
      - subscribe:
          topic: analytics/sensor-data/batch
        publish:
          topic: analytics/anomalies/detected
        rules:
        - filter:
            expression: |
              (
                $avg := $average(readings.value);
                $std := $sqrt($sum($map(readings.value, function($v) { ($v - $avg) * ($v - $avg) })) / $count(readings.value));
                $anomalies := $filter(readings, function($r) { $abs($r.value - $avg) > (2 * $std) });
                $count($anomalies) > 0
              )
    # Input Messages:
    # analytics/sensor-data/batch: {
    #   "batch_id": "B001",
    #   "readings": [
    #     {"sensor": "S1", "value": 22.1}, {"sensor": "S2", "value": 22.3}, 
    #     {"sensor": "S3", "value": 22.0}, {"sensor": "S4", "value": 35.8}
    #   ]
    # } ← PASSES (S4 value 35.8 is >2 std deviations from mean)
    #
    # analytics/sensor-data/batch: {
    #   "batch_id": "B002", 
    #   "readings": [
    #     {"sensor": "S1", "value": 21.8}, {"sensor": "S2", "value": 22.1},
    #     {"sensor": "S3", "value": 22.4}, {"sensor": "S4", "value": 22.0}
    #   ]
    # } ← FILTERED (all values within normal range)
    #
    # Output Messages (only batches with statistical anomalies):
    # analytics/anomalies/detected: {
    #   "batch_id": "B001",
    #   "readings": [array with anomalous sensor data]
    # }